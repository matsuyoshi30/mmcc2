#+title: memo
#+author: matsuyoshi30

* <2021-02-17 水>

  多次元配列のサポート追加しようと思って軽くパーザーに手を入れて終わりや！と思ったらテストでコケた。 dereference ノードの型が配列のときはレジスタにロードしてはいけない。するなら配列全体をレジスタにロードしないといけないが、一般的に配列型の変数はレジスタにロードしないことで「 C で配列の最初の要素へのポインタに自動的に変換される」という挙動が起こる。

* <2021-02-16 火>

  いい加減前回の C のコミットログを順番に見ていって実装していくやり方を変えたほうが良いかな。これだと初めてサポートした機能にバグがあって修正するというのも繰り返していてなんだかまるで成長していない…感が強い。今日も早速 sizeof のミスを修正。

* <2021-02-15 月>

  配列の実装に入ってるんだが早速昨日の懸念が顕在化した。今まだ配列の [] 演算子をサポートしていないので、int x[3] と宣言されている配列型の変数で x[1] にアクセスするのは暗黙的に *(x+1) と変換しているが、本来であればスタック領域に x[2], x[1], x[0] の順に下に伸びていく形で格納されており、配列の要素へのアクセスは配列用に確保しているスタック領域の最下が配列の先頭担っているので、そこから上にオフセットを計算していくことで参照できる。

  今、ポインタ型の変数や配列型の変数に関する加減算は逆に計算しているので、配列の先頭を指す箇所から下にオフセットを計算してメモリアクセスしている。これを修正しなければいけないが、ここでまた配列型の変数は加減算を逆にしない、とするとまたどこかでハマりそう。今のうちに直感的なパーザーにしたいところ。

  やはりコード生成のタイミングでオフセットを再計算することにした。変数参照時はノードのオフセットを見ていたが、ノードは再計算結果が反映されないというのは前に書いた。ここではコード生成用の構造体に var_offsets というフィールドを追加して、 usize の Vector を保持するようにした。これはある Function のコード生成の開始時に空で初期化し、オフセット再計算のタイミングで再計算したオフセットを保持する。じゃあ変数参照時にどうやってロードするのかというと、ローカル変数の構造体に id というフィールドを追加し、宣言順にインクリメントするようにした。変数ノードは変数構造体を保持しているので、変数参照時にそのノードから変数、そして変数の id を取得する。オフセット計算時に Vector に詰めていたのも宣言順なので、 id をインデックスとして var_offsets から再計算したオフセットが取得できる。これでポインタ演算や配列型の変数演算について直感的な関数に修正することができた。なおノードや変数はオフセットをもたないようになったので、コード生成では再計算ではなく純粋な計算である。

  このアイデアは、 C コンパイラ自作 Slack で Rust で書いていた方のコードを参考にさせていただいた。この方も最初ポインタ演算の加減算を逆にしていたが、配列をサポートするタイミングでやはりもとにもどしたようで、もどしかたのアイデアでなるほど！となった。

  https://github.com/kumojan/rnc/commit/4c054cd6089c4dd573b057a9af60a55c3711f70b

  [] 演算子のサポートも追加。これは a[1] を *(a+1) に読み替えるようパーズするだけなので簡単。なお 1[a] でもいけるとかいう C の狂った仕様はサポートしてない。 [] の前に識別子が来て [] 内は式という構文でパーズしてるので。

* <2021-02-13 土>

  ポインタ演算やる。 C のときは新しい変数がパーズされるたびに、変数を保持するスタックが下に伸びてメモリアドレスは減算されるが、コード生成時に変数のオフセットを再計算することで、古い（前にパーズされた）変数のオフセットを大きく、新しい（後にパーズされた）変数のオフセットを小さくするようにしていた。こうすることで int x=3; int y=5; return *(&x+1); のように古い変数 x の次のスタック領域にある変数を直感的なポインタ演算で可能にしていた。（オフセットを再計算しないと &x-1 が y のアドレスを指すようになる）

  今回はパーズ時に変数は Vector に追加していきそれぞれのオフセットは加算されていた。関数のプロローグでローカル変数分のスタック領域を確保するのは変わらない。コード生成時のオフセット再計算を失念していたので、前回のテストのときに古い変数から新しい変数のスタック領域を指そうとして -1 していた。

  今回もコード生成のときに変数のオフセットを再計算しようとしたが、再計算時は Function 構造体がもつ locals という Vector についてループを回してオフセットを再計算するだけでは足りない。変数から値をロードするコードを生成するときは node 構造体が保持する lvar からオフセットを取得しており、これは locals 内の lvar とは違う実体で前述の再計算の対象にならない。 C の場合は同じように node 構造体に lvar をポインタ型のフィールドとして保持しておけば、再計算時の func->locals がもつ lvar と node 構造体が持つ lvar が同じ実体を指しているので、プロローグ前にオフセットを再計算すればどちらも対象になっていたのだった。

  今回は「ポインタ演算の加減算は逆でパーズする」とした。生成されるアセンブリで変数のスタック状態が C とは異なるがまあ配列計算のときもポインタ演算の加減算用関数使えば大丈夫と思うので、とりあえずこれで。ハマったらここまで戻ってきてやり直します。

  sizeof 演算子追加。後ろのトークンをみて数値ノードを返すだけ。

* <2021-02-09 火>

  ポインタ領域に入る。まず & と * のサポートを追加してポインタ演算の準備。割とサクッと終わり。

  ポインタ型を導入したあとのテストでうまく行かない箇所があって、理由に気づくのに少し時間かかった。 int x; x=3; int *y; y=&x; としたあとに *y=5; で x の値を書き換えようというテストなんだが、代入式のパーズで *y は type ident と判定されて、今はまだ初期化式（NOT EQUAL 代入式）をサポートできていないのが原因だった。とりあえずサポートしてないのでテストはケースから落として今日は終わり。

* <2021-02-08 月>

  今日は int 追加してようやく C っぽい見た目にするぞ〜。目標は関数定義のときに戻り値の型を表す箇所の int のサポートと、関数定義のときの引数の型を表す箇所の int サポートと、変数宣言のときの型を表す箇所の int サポート。つまり int main() とか int fib(int n) とか int a; とか。これは int なしの状態はサポートできているので、それぞれ該当の箇所に型リテラルが来るような文法にする。なんか意外とサクッとできた。

  しかしソースが汚い。たぶん Rust っぽく書けてないしトークン列を次に進めるのにいちいち pos をインクリメントしたり期待するトークンかどうかを判定するのは文字列との比較だったり。

  とりあえず汚いなと目につく箇所はキレイにしてみた。あとコメントつけたり。しかし Rust はコンパイル時間かかるなー。

* <2021-02-07 日>

  日付変わったからこっち書くけど昨日の続きでブロック構文までサポートした。

  引数を持たない関数の呼び出しをサポート、その後に引数を最大6個まで持てる関数の呼び出しをサポート。ここの最大個数は引数用に使えるレジスタを6個までしか用意してないってことなんだけど、ここらへん無制限に持てるようにできる方法が Slack で話されてた気がする。気が向いたらサポートしよう。

  次は関数定義。関数を表す構造体を定義して parser のフィールドに関数の Vector を追加。 parser は main とその他0個以上の関数を持つ。関数ごとのローカル変数をどうするかで悩み中。 parser に temp なローカル変数用フィールドを用意して、関数のパーズが終わったらパーズしてきた関数のローカル変数エリアにコピーして temp は初期化する、みたいな流れにしよう。そしたら func.locals = self.temp_locals; はローカル変数を表す構造体に Copy トレートが実装されてないからダメだった。さらに、単純にローカル変数の構造体に Copy トレートを継承しようとしたんだが、 String を持つ構造体は Copy トレートを継承できないとのことでまた怒られた。

  https://stackoverflow.com/questions/38304666/how-to-define-a-copyable-struct-containing-a-string

  うーんどうしようかと悩んだが、コピーしたい Vector を clone() することで対応できた。

* <2021-02-06 土>

  さて変数。一文字だけ、 a から z までを変数に使えるやつ。この先実装予定の複文に備えるために、同時に文末のセミコロンもサポートした。セミコロンで文を切ってそこまでの文の塊を一つの Node として、複数の文を持つときは Vec<Node> で AST を保持しておいて、コード生成はこれを一個ずつ作り文の最後で pop rax で値を捨てるようにする。 Vec<Node> は C ではグローバル変数として定義したがここでは parser のフィールドとして持つことにした。

  コード生成のとき、 Vec<Node> のイテレーションを回して生成しようと思っていたが、独自に定義した構造体は Iterator トレートを実装しないとイテレータを使えないようで、コンパイラに怒られた。まあまだ単一の文しかサポートしてないし、あとは for in でもできるので一旦は for in で対応した。

  一文字の変数対応できたから二文字以上も変数として使えるように対応。変数名に使える文字かどうかを判断する関数とか追加するだけ。あとはすでに使用された変数名は再度代入式があっても同じスタック領域に値を設定するように、同じオフセットをとってくるようにした。このために使用された変数名とオフセットのペアをどこかに保存しておく必要があるので、 parser にローカル変数の Vector を持つようにした。変数のトークンをパーズするときは parser の locals を探索して、なければ新規に作って追加、あればオフセットを取得するという流れ。

  勢いで return を追加する。トークナイザのときに変数名っぽいが return のときは識別子ではなく予約語のトークンを作る。パーズするときは文が expr ; か return expr ; なので判定し return 用のノードを作る（右枝先は使わない）。コード生成のときは panic を起こさないよう先頭で return ノードかどうかを判定し、 return ノードなら左枝先分の式のコードを生成し、それをリターンするアセンブリを追加して終わる。

  そろそろファイル分割するか。

  https://doc.rust-jp.rs/book-ja/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html

  main.rs と同階層に分けたファイルの Public な構造体とか関数とかはそのまま main.rs など同階層のほかファイルで使用できない。なぜかというと Cargo がコンパイルするときは src/main.rs をバイナリクレートのルート、 src/lib.rs をライブラリクレートのルートと認識するので、他のファイルで定義された関数などを main.rs で使用するためには、 ライブラリクレートのルートである src/lib.rs でモジュールを公開して main.rs がそれを参照する。

  そんなことやらなくてよかったガハハ。再利用性とか考えてモジュールを適切に分割して作る場合は上記のやり方が良いんだろうけど、今回は main.rs と同階層にファイル（モジュール）を分けて、 main.rs 内でモジュールを宣言して、ほかファイルの関数とか使うときはモジュールツリーから絶対パスで use crate::modulename::something ってすればよかった。

  if 文サポートしようとおもったら、 Rust では可変な静的変数は Unsafe 関数かブロック内でしか使えないよう（言語思想的にそれはそう）で、なんかスマートなやり方を考えないとなーとなった。ぽろぽろみてたら、コード生成用の構造体を定義して、ラベル用の整数をフィールドに持ち、ラベル整数を返してそれをインクリメントするメソッドを用いるのが良さそうだったのでそうした。うーんでも diff がつらい。でもこれ以外いい方法が思いつかないのでこれでいこう。

  if-else がサポートされればほぼ同じ構造のループもできるので while も for-loop も追加。とおもたら for-loop の condition 部分バグ仕込んでて直し。これ mmcc のときもやっててあとから直してたので成長してない、というか本当は覚えていないといけないやつー。

* <2021-02-04 木>

  今日は二文字で形成される比較演算子について実装していく。 >= とか != とか。の前にトークナイザで new_token とか実装しといたほうが良さそうなのでリファクタ。

  さてまずは >= と <= を実装、というところで、String のパターンマッチで混乱した。そもそも Rust には String とか &str とか Vec<char> とかあるのでここらへん理解してないとすぐにハマる。ハマってもコンパイラが教えてくれるのでそこまで困らないが。

  何にハマったかというと、 if 文では String と "" (&str) の比較ができるのにパターンマッチではできないという点。パターンマッチしたいものが String のときはそれを &str にするかパターンのほうを String にして合わせるしかない。 String -> &str はヒープ領域のポインタをとってくるだけなのでメモリアロケーションは発生しないが、 &str -> String はメモリアロケーションが発生するので as_str() で String を &str に変換することにした。

  https://stackoverflow.com/questions/49886160/why-can-i-compare-a-string-to-a-str-using-if-but-not-when-using-match

  てかバグあった。 mmcc の方にもあった。 < の AST ノードに対するアセンブリが間違ってた。境界条件のテスト漏れ。

  バグ直して >=, <= と同じように == とか実装。これで四則演算と比較演算はおわり、次は変数。

* <2021-02-03 水>

  今日は AST を構築するパーザを Node 構造体のメソッドとして実装しなおす。しなおした。簡単。 impl Node ブロック内に移動して Node を Self に書き換えるだけでいけた。

  しかしこれは本来のメソッド記法とは違う気がする。すべて Node::method() で呼び出している。いわゆる「関連関数」のかたち。 String::from() みたいな。これは一般的には新規インスタンスを作るときに使用されるもので、想定しているのはノードを作りながら AST を構築していくように呼び出しあう関数群だったので、いまいち正しい使い方ではない感覚を覚えた。このままでも良かったのかもしれないけど。

  なので新しく Parser という構造体を定義してこの構造体に AST 構築用のメソッドを定義することにした。それぞれのメソッドは Node を返すんだけどメソッドの中で再帰下降構文に従いながらメソッドを呼び出しあう。 Parser はトークン列と今どのトークン列をみているかのインデックスを保持するようにし、各メソッドはパーザー自身を可変参照の引数として定義されているので、いわゆるメソッド的に self.method() というかたちで呼び出せる。これはなんかオブジェクト指向っぽい。

  Rust のコンパイラが親切なので、「だいたいこんな感じでいけるかな」と思って書き殴ってコンパイルして出てきたエラーのヘルプメッセージどおりに直していったら動いた。 "help: indicate the anonymous lifetime: `<'_>`" は、参照を含む構造体はライフタイムを指定しないといけないが、その構造体にメソッドを定義したときは impl ブロックでもライフタイムを示さないといけないというやつ。 "error[E0312]: lifetime of reference outlives lifetime of borrowed content.." はライフタイム参照を持つ構造体について、引数をライフタイム指定したフィールドに設定するようなコンストラクタでも引数にライフタイム指定しましょうというもの。これは後ろに "but the borrowed content is only valid for the anonymous lifetime #1 defined on the method body a xxx" とあるのも分かりやすい。

* <2021-02-02 火>

  比較演算子。まずは一文字のパーズだけやってみる。 > と < 。サクッと完了。

* <2021-02-01 月>

  少し日が空いてしまった。今日は単項演算子を実装する。

  単項演算子は今まで primary として AST ノードをつくっていたところが、+ があればそのまま、 - があれば 0-x のかたちとして読み込むようにすればよい。しかし Rust のビルドは遅いな。

  と思ったら既存のコードにバグがあった。 expr 内で左枝先ノード探索後のトークン位置を示す pos の更新の方法が誤っていました。今までのテストはうまく動いて単項演算子の実装で気づくという。こういうのコンパイラ作ってるあるあるな気がする（ある実装で別の既存の実装のバグに気づく）

* <2021-01-28 木>

  カッコの対応をする。これができたら電卓レベルになる（整数のみだが）。

  とりあえずは昨日までと同じように括弧で閉じられた式を AST ノードに変換する関数を実装する。かんたん。

  いちいちインスタンス化のたびに構造体の全フィールドを書くのはつらいので、定義した構造体に Default() を実装した。標準ライブラリで Default トレイトが定義されており、構造体のフィールドの型が標準の型であれば、 #[derive(Default)] という注釈を付与することで、インスタンス化するときに手動で設定する必要のないフィールドは ..Default::default() を呼び出すことで型のデフォルト値（ Go でいうゼロ値かな？）が設定される。

  自分は定義した構造体にまた別で定義した Enum のフィールドがあったので  Default() を実装した。その用途から大体はインスタンス化のときに構造体のブロックの中で使用されるものだが、 Node 構造体に対して実装した Default トレイトの場合、 Default::default() でも Node::default() でもどちらでも呼び出せる。たぶん Default トレイトを実装していますよということで Default::default() のほうがよいのだと思うが。

  次は構造体に対してメソッドを定義してそれを呼び出す形に書き換える。それか単項演算子の実装。

* <2021-01-27 水>

  乗算と除法。加減算との計算の優先順位とか考えないといけないので、乗除算と加減算で AST ノードを作る関数を分けてうまくやる（ここらへんは Compilerbook で解説されている左再帰下降構文解析を適用する）。

  C の場合はトークン列をグローバルに宣言した隣接リスト型の変数で表しているので、乗除算と加減算で AST を作るときはそれぞれそのグローバル変数を見ればよかったのだが、今回トークン列は Vector で表している。なので計算の優先順位が低い加減算の関数は引数にトークン列を、計算の優先順位が高い乗除算は引数にトークン列と今ターゲットにするトークン列のインデックスを持つようにした。加減算ではオペレーターのあとに必ず乗除算の関数を呼び、乗除算はオペレーターのあと、もしくはオペレーターがない場合に数値を読んで、ノードと新しくターゲットとなったトークン列のインデックスを返す。これで乗除算と加減算間でトークン列をうまい具合にやり取りすることができる。

  引数にトークン列を受け取ってやり取りする場合は参照でやりとりする。これを Rust では「参照による所有権の借用」という。ここまでのざっくりとした所有権の理解は、「関数の仮引数に変数を渡すと所有権が移動(move)するので関数呼び出し以降はその変数は使えない。仮引数に参照で借用すればそれ以降も同一の変数が使用できる」という感じ。ゼッタイにもっと厳密な定義があるので公式ドキュメント読もう。

  https://doc.rust-jp.rs/book-ja/ch04-00-understanding-ownership.html

* <2021-01-26 火>

  トークンの列から AST を作る。

  Enum でノードの種類を定義し、ノード情報を表す構造体を定義。連結リストは標準データ型の Vector を使えばよかったのでトークン列は Vector をつかったが、 AST はその名の通り木構造のデータなので Rust で木構造データを表現する方法を調べる。

  枝先を示すフィールドの型をどうするか。持つものは同じノード構造体なんだが、そのままでは再帰的な型定義になってサイズが確定しない（無限大になる）。C では枝先を示すポインタを持てばよかったが Rust だと Box<> というのを使うらしい。 Box を使うことで <> 内のデータをヒープ領域に確保する。

  一番目のトークンは数値として AST のノードを作り、以降は無限ループの中で処理する。'+' か '-' であればトークン列のインデックスを一つずらして数値を取得して「ノードの左枝先は元のノード、右枝先は取得した数値、ノード自身は operator 」のノードを作って「元のノード」が自分を指すようにする。「1+2-3」はこんな感じのノードになる。

  #+begin_src
       -
      / \
     +   3
    / \
   1   2
  #+end_src

    ノード生成のところで左右枝先のデータ型を Option<Box<Node>> にしたためになかなか苦戦したが、ここはさすが Rust 、コンパイラが親切でコンパイルエラー一つ一つ丁寧に対応してたらいつの間にかできてた。ただなんかもっと良い書き方がゼッタイにある。なんか煩雑。

    コード生成もここで関数に切り出す。 AST のルートノードを受け取るとトラバースしながらアセンブリを出力する。ここは C で実装したコードと同じ感じで実装できそう。そしてできた。昨日構造体のフィールドに対してパターンマッチかけないとか言ったけど書けたわ。さすがに書けるか。ガハハ

* <2021-01-25 月>

  tokenizer の実装。

  初めに Enum でトークンの種類を定義。後で気づくが比較演算で Enum をこのまま使うことはできないので #[derive(PartialEq)] を用いて比較できるようにする。

  https://stackoverflow.com/questions/25576748/how-to-compare-enum-without-pattern-matching

  トークンの構造体を定義。 C では連結リストを実装するために次のトークンのポインタを内蔵したが、 Rust では Vector が使えるので不要。

  トークナイザを実装。文字列を受け取ってトークンの Vector を返す。インスタンス生成時に設定不要なフィールドについては、構造体に Default を実装してそれを使うことで記述の簡略化が図れるらしいが、なんかうまくいかなかったので後で見直す。今日はどのインスタンス化でもすべてのフィールドを設定するように書いた。

  パターンマッチを使いこなしたいんだけどなんかうまくかけない。例えばトークンの種類によって処理を分岐したいというときに、 match tokens[i].TokenKind と書いて TkReserved, TkEof, _ のパターンでそれぞれ書くみたいにできると直感的なのかなと思ったのだが、インスタンスのフィールドについてのパターンマッチはかけずにインスタンスそのもののパターンマッチを書かなければいけないようだ。ここでも検査不要なフィールドは .. で省略できるが、なんでフィールドでパターンマッチできないんだろう？

  https://stackoverflow.com/questions/41390457/how-to-match-struct-fields-in-rust

* <2021-01-24 日>

  Rust で C Compiler 書き始め。まずは恒例、コマンドラインで受け取った整数をそのまま EXIT CODE に使うアセンブリを出力。

  その後は加減算を実装。 C では、文字列の先頭からN進数としてパーズできるものとパーズ後の残りの文字列のポインタを返してくれる strtol 関数が便利だったが、 Rust では同等の関数がなさそうなので調べながら実装
  イテレータを便利に使ってワンライナーでこういうのをかけるのが Rust の良いところのひとつなのかな？

  https://doc.rust-lang.org/std/iter/trait.Iterator.html

  https://qiita.com/lo48576/items/34887794c146042aebf1

  strtol っぽい関数は書いたんだが、オペレーターをみて加減算を判断するところの実装が少し手間取った。Rust は文字列を表すデータ型に String, &str, Vec<char> など色々あり、色々あるということはそれぞれ違うところもあり。ループで文字列操作したい場合は &str ではなくて String を使う。

  https://stackoverflow.com/questions/59022234/borrowed-value-does-not-live-long-enough-in-loop

  https://stackoverflow.com/questions/29428227/return-local-string-as-a-slice-str
